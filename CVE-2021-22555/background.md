# 0x00 消息队列

## `msgget()`
创建和访问一个消息队列

```c
int msgget(key_t key, int msgflg);
```
- `key`
- `msgflg`


## `msgsnd()`

把消息添加到消息队列中

```c
int msgsnd(int msgid, const void *msg_ptr, size_t msg_sz, int msgflg);
```

- `msgid`：`msgget`的返回值
- `msg_ptr`：指向一个准备发送消息结构体的指针，该结构体必须以长整形作为头部

```c
struct my_message{
	long int message_type;
	//data
};
```

- `msg_sz`：`msg_ptr`指向的消息的长度
- `msgflg`

### `msgsnd()`在内核中的实现

`msgsnd()`执行进入到内核后，会调用到内核的函数`alloc_msg()`

```c
static struct msg_msg *alloc_msg(size_t len)
{
	struct msg_msg *msg;
	struct msg_msgseg **pseg;
	size_t alen;

	alen = min(len, DATALEN_MSG);//这里DATALEN_MSG即为PAGE_SIZE - sizeof(struct msg_msg)
	msg = kmalloc(sizeof(*msg) + alen, GFP_KERNEL_ACCOUNT);
	if (msg == NULL)
		return NULL;

	msg->next = NULL;
	msg->security = NULL;

	len -= alen;
	pseg = &msg->next;
	while (len > 0) {
		struct msg_msgseg *seg;

		cond_resched();

		alen = min(len, DATALEN_SEG);//这里DATALEN_SEG即为PAGE_SIZE - sizeof(struct msg_msgseg)
		seg = kmalloc(sizeof(*seg) + alen, GFP_KERNEL_ACCOUNT);
		if (seg == NULL)
			goto out_err;
		*pseg = seg;
		seg->next = NULL;
		pseg = &seg->next;
		len -= alen;
	}

	return msg;

out_err:
	free_msg(msg);
	return NULL;
}
```

`len`是用户层传来的消息的长度，加上头部长度超过一页时会根据`len`的大小将消息分段，每一段有一个头部。其中第一段的头部为`struct msg_msg`，结构体定义如下：

```c
struct msg_msg{
	struct list_head m_list;
	long m_type;
	size_t m_ts;
	struct msg_msgseg *next;
	void *security;
};
```

- `m_list`：典型的链表头，指向消息队列中的下一条消息
- `m_type`：
- `m_ts`：返回到用户空间的长度
- `msg_msgseg`：指向下一个segment【构成链表，其中msg_msg是链表头】，结构体定义如下：

```c
struct msg_msgseg{
	struct msg_msgseg *next;
}
```

- `security`

## `msgrcv`
从一个消息队列获取消息
```c
int msgrcv(int msgid, void *msg_ptr, size_t msg_st, long int msgtype, int msgflg);
```

- `msgtype`：实现简单的接收优先级：如果为0则获取队列中第一个消息，如果大于0则获取相同消息类型的第一个消息，如果小于0则获取类型等于或小于绝对值的第一个消息。
- `msgflg`：
	- `IPC_NOWAIT`：立即返回
	- `MSG_COPY`：无损的从消息队列中取出第msgtype条消息（注意消息顺序从0开始计算），必须和`IPC_NOWAIT`搭配使用，而且要求内核开启`CONFIG_CHECKPOINT_RESTORE`编译选项。
> Nondestructively fetch a copy of the message at the ordinal position in the queue specified by msgtype

### `msgrcv()`在内核中的实现

`msgrcv()`会在内核中调用到`ipc/msgutil.c`中的`copy_msg`,该函数负责从内核地址空间复制到用户地址空间。复制的长度由alen指定，alen是len和DATALEN_MSG之间的较小值。故alen最大为DATALEN_MSG

```
struct msg_msg *copy_msg(struct msg_msg *src, struct msg_msg *dst)
{
	struct msg_msgseg *dst_pseg, *src_pseg;
	size_t len = src->m_ts;
	size_t alen;

	if (src->m_ts > dst->m_ts)
		return ERR_PTR(-EINVAL);

	alen = min(len, DATALEN_MSG);
	memcpy(dst + 1, src + 1, alen);

	...
	return dst;
}
```

# 0x01 `setsockopt`系统调用

将指定的参数设定到指定的socket上

```c
#include <sys/socket.h>
int setsockopt(int socket, int level, int option_name, const void *option_value, socklen_t option_len);
```

- `socket`
- `level`：指定了协议的层级
- `option_name`：在`<sys/socket.h>`中被指定

```
SO_ACCEPTCONN Socket is accepting connections.
SO_BROADCAST  Transmission of broadcast messages is supported.
SO_DEBUG      Debugging information is being recorded.
SO_DONTROUTE  Bypass normal routing.
SO_ERROR      Socket error status.
SO_KEEPALIVE  Connections are kept alive with periodic messages.
SO_LINGER     Socket lingers on close.
SO_OOBINLINE  Out-of-band data is transmitted in line.
SO_RCVBUF     Receive buffer size.
SO_RCVLOWAT   Receive ``low water mark''.
SO_RCVTIMEO   Receive timeout.
SO_REUSEADDR  Reuse of local addresses is supported.
SO_SNDBUF     Send buffer size.
SO_SNDLOWAT   Send ``low water mark''.
SO_SNDTIMEO   Send timeout.
SO_TYPE       Socket type.
```

当`option_name`被指定为IPT_SO_SET_REPLACE时，调用函数需要`CAP_NET_ADMIN`权限（在函数`compat_do_ipt_set_ctl`中进行检查），进入内核后会调用到存在漏洞的函数`xt_compat_target_from_user`。


# 0x02 `ENTER 0,0`指令

`ENTER 0,0`指令表示结束当前栈帧，开启下一个栈帧。其相当于：

```
push rbp
mov rsp, rbp
```

与其对应的是`LEAVE`指令，其反转了ENTER指令的操作：

```
mov rsp,rbp
pop rbp
```


# 0x03 内核内存分配机制

## Zone

## 伙伴系统

## slub分配器

# 0x04 管道

用户态调用`pipe()`创建管道，内核层中会调用`fs/pipe.c`中的`alloc_pipe_info()`

```c
struct pipe_inode_info *alloc_pipe_info(void)
{
	...
	unsigned long pipe_bufs = PIPE_DEF_BUFFERS;
	...
	pipe = kzalloc(sizeof(struct pipe_inode_info), GFP_KERNEL_ACCOUNT);
	if (pipe == NULL)
		goto out_free_uid;
	...
	pipe->bufs = kcalloc(pipe_bufs, sizeof(struct pipe_buffer),
			     GFP_KERNEL_ACCOUNT);
	...
}
```

其中`struct pipe_buffer`如下所示：

```c
struct pipe_buffer {
	struct page *page;
	unsigned int offset, len;
	const struct pipe_buf_operations *ops;
	unsigned int flags;
	unsigned long private;
};

struct pipe_buf_operations {
	...
	/*
	 * When the contents of this pipe buffer has been completely
	 * consumed by a reader, ->release() is called.
	 */
	void (*release)(struct pipe_inode_info *, struct pipe_buffer *);
	...
};
```

其中`pipe_buf_operations`在.data段，其位置相对于内核基址固定。

## 获取其在内核中的位置

利用编译好的vmlinux获取：

```
nm vmlinux | grep anon_pipe_buf_ops
```

# 0x05 `__attribute__((__packed__))`

gcc编译器定义的宏，用于修饰特定的结构体。编译器在编译被`__attribute__((__packed__))`修饰的结构体时将不进行内存的对齐，保证结构体大小即为结构体中各个域所在内存空间之和。


# 0x06 socketpair

`socketpair()`在特定的domain中创建一对匿名的相互连接的套接字

```c
#include <sys/socket.h>
int socketpair(int domain, int type, int protocol, int sv[2])
```

文件描述符`sv[0]`和`sv[1]`将会被返回

